class VulnerabilityScanner {
  constructor() { this.vulnerabilities = []; this.scans = []; this.plugins = []; }
  addPlugin(plugin) {
    this.plugins.push(plugin);
    return this.plugins.length - 1;
  }
  async scan(target, options={}) {
    const scan = {
      id: Date.now() + Math.random(),
      target,
      options,
      startTime: Date.now(),
      status: 'running',
      findings: []
    };
    this.scans.push(scan);
    for (const plugin of this.plugins) {
      try {
        const findings = await plugin.scan(target, options);
        scan.findings.push(...findings);
      } catch (error) {
        scan.findings.push({
          plugin: plugin.name,
          error: error.message,
          severity: 'error'
        });
      }
    }
    scan.endTime = Date.now();
    scan.duration = scan.endTime - scan.startTime;
    scan.status = 'completed';
    scan.findings.forEach(finding => this.addVulnerability(finding));
    return scan;
  }
  addVulnerability(vuln) {
    vuln.id = vuln.id || Date.now() + Math.random();
    vuln.discoveredAt = vuln.discoveredAt || Date.now();
    vuln.status = vuln.status || 'open';
    this.vulnerabilities.push(vuln);
    return vuln.id;
  }
  getVulnerabilities(filters={}) {
    return this.vulnerabilities.filter(vuln => {
      if (filters.severity && vuln.severity !== filters.severity) return false;
      if (filters.status && vuln.status !== filters.status) return false;
      if (filters.target && vuln.target !== filters.target) return false;
      if (filters.plugin && vuln.plugin !== filters.plugin) return false;
      return true;
    });
  }
  getScans(filters={}) {
    return this.scans.filter(scan => {
      if (filters.target && scan.target !== filters.target) return false;
      if (filters.status && scan.status !== filters.status) return false;
      return true;
    });
  }
  getScan(id) {
    return this.scans.find(s => s.id === id);
  }
  getStats() {
    const stats = {
      total: this.vulnerabilities.length,
      bySeverity: {},
      byStatus: {},
      byPlugin: {},
      totalScans: this.scans.length,
      recentScans: this.scans.filter(s => Date.now() - s.startTime < 24 * 60 * 60 * 1000).length
    };
    this.vulnerabilities.forEach(vuln => {
      stats.bySeverity[vuln.severity] = (stats.bySeverity[vuln.severity] || 0) + 1;
      stats.byStatus[vuln.status] = (stats.byStatus[vuln.status] || 0) + 1;
      stats.byPlugin[vuln.plugin] = (stats.byPlugin[vuln.plugin] || 0) + 1;
    });
    return stats;
  }
  updateVulnerabilityStatus(id, status) {
    const vuln = this.vulnerabilities.find(v => v.id === id);
    if (vuln) {
      vuln.status = status;
      vuln.updatedAt = Date.now();
      return true;
    }
    return false;
  }
}
window.VulnerabilityScanner = VulnerabilityScanner;